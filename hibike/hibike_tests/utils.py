"""
General utilities for unit tests.
"""
import asyncio
import unittest

def run_with_random_data(func, arg_func, kwarg_func=lambda: {}, times=5):
    """
    Test FUNC with random arguments generated by ARG_FUNC and
    KWARG_FUNC, repeating TIMES.

    ARG_FUNC should return an iterable.
    """
    for _ in range(times):
        func(*arg_func(), **kwarg_func())


class AsyncTestCase(unittest.TestCase):
    """
    A test case that creates an event loop before a test and
    stops it afterwards. Useful for unit testing coroutines.
    """
    def setUp(self):
        self.loop = asyncio.new_event_loop()

    def tearDown(self):
        try:
            # Python will deprecate and remove ``Task.all_tasks`` in the future,
            # but not all versions have ``asyncio.all_tasks``, so just do both.
            tasks = asyncio.Task.all_tasks(self.loop)
        except AttributeError:
            # pylint: disable=no-member
            tasks = asyncio.all_tasks(self.loop)
        for t in tasks:
            t.cancel()
        try:
            self.loop.run_until_complete(asyncio.gather(*tasks, loop=self.loop))
        except asyncio.CancelledError:
            pass
        self.loop.stop()

    def run_until_timeout(self, task, timeout):
        """
        Run ``coro`` for up to ``timeout`` seconds.
        """
        async def stop_event_loop():
            await asyncio.sleep(timeout, loop=self.loop)

        stop_task = self.loop.create_task(stop_event_loop())
        # Note: Yes, pending is not used, but if you remove it,
        # async complains about cancelled coroutines
        # pylint: disable=unused-variable
        _, pending = self.loop.run_until_complete(asyncio.wait([task, stop_task],
                                                               return_when=asyncio.FIRST_COMPLETED))
